# 3. 복합키와 식별 관계 매핑

## 3.1 식별 관계 vs 비식별 관계

- 데이터베이스 테이블 사이 관계는 외래키가 기본키에 포함되는지 여부에 따라 식별 관계와 비식별 관계로 구분한다.

### 식별 관계

- 부모 테이블의 기본키를 내려받아 자식 테이블의 기본키 + 외래키로 사용하는 관계다.

```
[     PARENT     ]            [      CHILD     ]
| PARENT_ID (PK) |            | PARENT_ID (PK) |
|----------------|-----------<| CHILD_ID (PK)  |
| NAME           |            |----------------|
                              | NAME           |
                              
                              
```    

### 비식별 관계

- 부모 테이블의 기본키를 받아서 자식 테이블의 외래키로만 사용하는 관계다.
- 비식별 관계는 외래키에 NULL을 허용하는지에 따라 아래와 같이 나뉜다.
    - 필수적 비식별 관계(Mandatory): 외래키에 NULL을 허용하지 않는다.
    - 선택적 비식별 관계(Optional): 외래키에 NULL을 허용한다.

```
[     PARENT     ]            [      CHILD     ]
| PARENT_ID (PK) |            | CHILD_ID (PK)  |
|----------------|-----------<|----------------|
| NAME           |            | PARENT_ID (FK) |
                              | NAME           |
```    

- 데이터베이스 테이블을 설계할 때 식별 관계나 비식별 관계 중 하나를 선택해야 한다.
- 최근에는 비식별 관계를 주로 사용하며 필요한 곳만 식별 관계를 사용하는 추세다.
- JPA는 식별/비식별 관계를 모두 지원한다.


## 3.2 복합키: 비식별 관계 매핑

- 기본키를 구성하는 컬럼이 하나면 다음처럼 단순하게 매핑한다.

```java
@Entity
public class Hello {
    @Id
    private String id;
}
```

- 둘 이상의 컬럼으로 구성된 복합 기본키는 별도의 식별자 클래스를 만들어야 한다.
- 식별자 필드가 2개 이상이면 `equals`와 `hashCode`를 구현해야 한다.
- JPA는 복합키를 지원하기 위해 `@IdClass`와 `@EmbeddedId`를 지원한다.
    - `@IdClass`는 관계형 데이터베이스에 가까운 방법
    - `@EmbeddedId`는 객체지향에 가까운 방법

### @IdClass

- `PARENT` 테이블의 기본키를 `PARENT_ID1`, `PARENT_ID2`로 묶은 복합키로 구성했다면...

```java
@Entity
@IdClass(ParentId.class)
public class Parent {
    @Id
    @Column(name = "PARENT_ID1")
    private String id1;     // ParentId.id1과 연결

    @Id
    @Column(name = "PARENT_ID2")
    private String id2;     // ParentId.id2와 연결
    
    private String name;
    // ...
}
```

- 위 클래스는 먼저 각각 기본키 컬럼을 `@Id`로 매핑했다.
- `@IdClass`를 사용해서 `ParentId` 클래스를 식별자 클래스로 지정했다.

```java
public class ParentId implements Serializable {
    private String id1; // Parent.id1 매핑
    private String id2; // Parent.id2 매핑

    public ParentId() {
    }

    public ParentId(String id1, String id2) {
        this.id1 = id1;
        this.id2 = id2;
    }

    @Override
    public boolean equals(Object obj) { /* ... */ }
    
    @Override
    public int hashCode() { /* ... */ }
}
```

- `@IdClass`를 사용할 떄 식별자 클래스는 다음 조건을 만족해야 한다.
    - 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다.
    - `Serializable` 인터페이스를 구현해야 한다.
    - `equals`, `hashCode`를 구현해야 한다.
    - 기본 생성자가 있어야 한다.
    - 식별자 클래스는 `public`이어야 한다.

```
// 실제 사용하는 방법
Parent parent = new Parent();
parent.setId1("myId1");
parent.setId2("myId2");
parent.setName("parentName");
em.persist(parent);
```

- `em.persist()`를 호출하면...
    - 영속성 컨텍스트에 엔티티를 등록하기 직전 식별자 클래스인 `ParentId`를 생성하고 
    - 영속성 컨텍스트의 키로 사용한다.

```
// 조회할 떄
ParentId parentId = new ParentId("myId1", "myId2");
Parent parent = em.find(Parent.class, parentId);
```

- 조회 코드를 보면 식별자 클래스인 `ParentId`를 사용해서 엔티티를 조회한다.

```java
@Entity
public class Child {
    @Id
    private String id;
    
    @ManyToOne
    @JoinColumns({
            @JoinColumn(name = "PARENT_ID1", referencedColumnName = "PARENT_ID1"),
            @JoinColumn(name = "PARENT_ID2", referencedColumnName = "PARENT_ID2")
    })
    private Parent parent;
}
```

- 부모 테이블의 기본키 컬럼이 복합키이므로 자식 테이블의 외래키도 복합키다.
- 따라서 여러 컬럼을 매핑해야 하므로 `@JoinColumn` 애노테이션을 사용하여 각각을 매핑해야 한다.
- `@JoinColumn`의 `name` 속성과 `referencedColumnName` 속성값이 같으면 `referencedColumName`은 생략해도 된다.

### @EmbeddedId

- `@IdClass`가 데이터베이스에 맞춘 방법이라면 이는 좀 더 객체지향적인 방법이다.

```java
@Entity
public class Parent {
    @EmbeddedId
    private ParentId id;
    
    private String name;
    // ...
}
```

- `Parent` 엔티티에서 식별자 클래스를 직접 사용하고 `@EmbeddedId` 애노테이션을 적으면 된다.

```java
@Embeddable
public class ParentId implements Serializable {
    @Column(name = "PARENT_ID1")
    private String id1;
    
    @Column(name = "PARENT_ID2")
    private String id2;
    
    // equals 및 hashCode 구현
    // ...
} 
```

- `@EmbeddedId`를 적용한 식별자 클래스는 식별자 클래스에 기본키를 직접 매핑한다.
- `@EmbeddedId`를 적용한 식별자 클래스는 다음 조건을 만족해야 한다.
    - `@Embeddable` 애노테이션을 붙여주어야 한다.
    - `Serializable` 인터페이스를 구현해야 한다.
    - `equals`, `hashCode`를 구현해야 한다.
    - 기본 생성자가 있어야 한다.
    - 식별자 클래스는 `public`이어야 한다.

```
// 실제 사용하는 방법
Parent parent = new Parent();
ParentId parentId = new ParentId("myId1", "myId2");
parent.setId(parentId);
parent.setName("parentName");
em.persist(parent);
```

- 저장할 땐 식별자 클래스 `parentId`를 직접 생성해서 사용한다.

```
// 조회할 떄
ParentId parentId = new ParentId("myId1", "myId2");
Parent parent = em.find(Parent.class, parentId);
```

- 조회 코드도 식별자 클래스 `parentId`를 직접 사용한다.

### 복합키와 equals(), hashCode()

- 복합키는 `equals()`와 `hashCode()`를 필수로 구현해야 한다.

```
ParentId id1 = new ParentId();
id1.setId1("myId1");
id1.setId2("myId2");

ParentId id2 = new ParentId();
id2.setId1("myId1");
id2.setId2("myId2");

id1.euqlas(id2) -> ?
```

- 위 코드는 `equals()`를 적절히 오버라이딩했다면 참이지만 아니라면 거짓이다.
- 영속성 컨텍스트는 엔티티의 식별자를 키로 사용해서 엔티티를 관리한다.
- 따라서 식별자 객체의 동등성(equals 비교)이 지켜지지 않으면 영속성 컨텍스트가 엔티티를 관리하는데 심각한 문제가 발생한다.

### @IdClass vs @EmbeddedId

- 각각 장단점이 있으므로 본인의 취향에 맞는 것을 일관성 있게 사용하면 된다.
- `@EmbeddedId`가 더 객체지향적이고 중복도 없어 좋아보이지만 특정 상황에 JPQL이 조금 길어질 수 있다.

```
// @EmbeddedId
em.createQuery("select p.id.id1, p.id.id2 from Parent p");
// @IdClass
em.createQuery("select p.id1, p.id2 from Parent p");
```

- 복합키에는 `@GeneratedValue`를 사용할 수 없다. 복합키를 구성하는 여러 컬럼 중에 하나에도 사용할 수 없다.

-----
[Home](./index.md)
