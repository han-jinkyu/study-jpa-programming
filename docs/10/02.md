# 2. JPQL

JPQL의 특징은 다음과 같다.

- 객체지향 쿼리 언어다. 따라서 테이블이 아닌 객체를 대상으로 쿼리한다.
- SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.
- 결국 SQL로 변환된다.


## 2.1 기본 문법과 쿼리 API

- JPQL은 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있다.
- 다만 저장은 `EntityManager::persist()`가 있으므로 INSERT문은 없다.

```
select_문 :: =
    select_절
    from_절
    [where_절]
    [groupby_절]
    [having_절]
    [orderby_절]
    
update_문 :: = update_절 [where_절]
delete_문 :: = delete_절 [where_절]
```

### SELECT 문

```
SELECT m FROM Member AS m WHERE m.username = 'Hello'
```

#### 대소문자 구분

- 엔티티와 속성은 대소문자를 구분한다.
- 반면 `SELECT, FROM, AS` 같은 JPQL 키워드는 대소문자를 구분하지 않는다.

#### 엔티티 이름

- JPQL에서 사용한 `Member`는 클래스 명이 아니라 **엔티티 명**이다.
- 엔티티 명은 `@Entity(name="XXX")`로 지정하며, 지정하지 않으면 클래스 명을 기본값으로 사용한다.

#### 별칭은 필수

- `Member AS m`을 보면 `m`이라는 별칭을 주었다.
- JPQL은 이를 필수를 지정해야 한다. 그렇지 않으면 잘못된 문법이라는 오류가 발생한다.
- 다만 `AS`는 생략할 수 있다.

### TypeQuery, Query

- 작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다.
- 쿼리 객체는 `TypeQuery`와 `Query`가 있다.
    - `TypeQuery`: 반환할 타입이 명확한 경우
    - `Query`: 반환할 타입이 명확하지 않은 경우
    
```
// 반환할 타입을 지정하면 TypeQuery를 반환한다.
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

List<Member> resultList = query.getResultList();
for (Member member : resultList) {
    System.out.println("member = " + member);
}
```

```
// 반환할 타입을 지정하지 않으면 Query를 반환한다.
Query query = em.createQuery("SELECT m.username, m.age FROM Member m");

List resultList = query.getResultList();
for (Object o : resultList) {
    Object[] result = (Object[]) o; // 결과가 둘 이상이면 Object[]를 반환
    System.out.println("username = " + result[0]);
    System.out.println("age = " + result[1]);
}
```

- 결과를 놓고 보면 `TypeQuery`가 더 편한 것을 알 수 있다.

### 결과 조회

- 다음 메서드들을 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회한다.
    - `query.getResultList()`: 결과를 리스트로 반환한다. 결과가 없다면 빈 컬렉션이 반환된다.
    - `query.getSingleResult()`: 결과가 정확히 하나일 때 사용한다.
        - 결과가 없으면 `javax.persistence.NoResultException` 예외가 발생한다.
        - 결과가 1개보다 많으면 `javax.persistence.NonUniqueResultException` 예외가 발생한다.


## 2.2 파라미터 바인딩

- JDBC는 **위치 기준** 파라미터 바인딩만 지원하지만 JPQL은 **이름 기준** 파라미터 바인딩도 지원한다.

#### 이름 기준 파라미터

- 이름 기준 파라미터(Named Parameters)는 파라미터를 이름으로 구분하는 방법이다.
- 이름 기준 파라미터 앞에는 `:`를 사용한다.

```
String usernameParam = "User1";

TypedQuery<Member> query = 
    em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class);
    
query.setParameter("username", usernameParam);
List<Member> resultList = query.getResultList();
```

- 참고로 JPQL API는 대부분 메서드 체인 방식으로 설계돼 있어 다음과 같이 연속해서 작성할 수 있다.

```
List<Member> resultList = 
    em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class)
        .setParameter("username", usernameParam)
        .getResultList();
```

#### 위치 기준 파라미터

- 위치 기준 파라미터(Positional Parameters)는 `?` 다음에 위치 값을 주면 된다.
- 위치 값은 **1**부터 시작한다.

```
List<Member> resultList = 
    em.createQuery("SELECT m FROM Member m WHERE m.username = ?1", Member.class)
        .setParameter(1, usernameParam)
        .getResultList();
```

- JPA는 파라미터 바인딩을 사용하면 파라미터 값이 달라도 같은 쿼리로 인식해 재사용할 수 있다.
- 결과적으로 애플리케이션과 데이터베이스 모두 해당 쿼리의 파싱 결과를 재사용해 전체 성능이 향상된다.


## 2.3 프로젝션

- SELECT 절에 조회할 대상을 지정하는 것을 프로젝션(Projection)이라 한다.
- 프로젝션 대상은 엔티티, 엠베디드 타입, 스칼라 타입이 있다.
- 스칼라 타입은 숫자, 문자 등 기본 데이터 타입을 뜻한다.

#### 엔티티 프로젝션

```
SELECT m FROM Member m          // 회원
SELECT m.team FROM Member m     // 팀
```

- 처음은 회원, 두 번째는 회원과 연관된 팀을 조회했는데 둘 다 엔티티를 프로젝션 대상으로 사용했다.
- 이렇게 조회한 엔티티는 영속성 컨텍스트에서 관리된다.

#### 임베디드 타입 프로젝션

- 임베디드 타입은 엔티티와 거의 비슷하게 사용된다.
- 다만 조회의 시작점이 될 수 없다는 제약이 있다.

```
String query = "SELECT o.address FROM Order o";
List<Address> addresses = em.createQuery(query, Address.class)
                            .getResultList();
```

```
SELECT
    order.city,
    order.street,
    order.zipcode
FROM
    Orders order
```

- 임베디드 타입은 엔티티가 아닌 값 타입이다. 따라서 영속성 컨텍스트에서 관리되지 않는다.

#### 스칼라 타입 프로젝션

- 숫자, 문자, 날짜와 같은 기본 데이터 타입을 스칼라 타입이라 한다.

```
List<String> usernames = em.createQuery("SELECT username FROM Member m", String.class)
                           .getResultList();
```

- 중복 데이터를 제거하려면 `DISTINCT`를 사용한다.

```
SELECT DISTINCT username FROM Member m
```

- 통계 쿼리도 주로 스칼라 타입으로 조회한다.

```
Double orderAmountAvg = em.createQuery(SELECT AVG(o.orderAmount) FROM Order o", Double.class)
                          .getSingleResult();
```

#### 여러 값 조회

- 꼭 필요한 데이터만 선택해서 조회해야 할 때도 있다.
- 프로젝션에 여러 값을 선택하면 `TypeQuery`는 사용할 수 **없다**.

```
Query query = em.createQuery("SELECT m.username, m.age FROM Member m");
List resultList = query.getResultList();

Iterator iterator = resultList.iterator();
while (iterator.hasNext()) {
    Object[] row = (Object[]) iterator.next();
    String username = (String) row[0];
    Integer age = (Integer) row[1];
}
```

- 제네릭에 `Object[]`를 사용하면 다음 코드처럼 간결하게 개발할 수 있다.

```
List<Object[]> resultList = em.createQuery("SELECT m.username, m.age FROM Member m")
                              .getResultList();

for (Object[] row : resultList) {
    String username = (String) row[0];
    Integer age = (Integer) row[1];
}
```

- 스칼라 타입 뿐만 아니라 엔티티 타입도 여러 값을 함께 조회할 수 있다.
- 이 때 조회한 엔티티는 영속성 컨텍스트에서 관리된다.

```
List<Object[]> resultList = 
    em.createQuery("SELECT o.member, o.product, o.orderAmount FROM Order o")
      .getResultList();
      
for (Object[] row : resultList) {
    Member member = (Member) row[0];        // 엔티티
    Product product = (Product) row[1];     // 엔티티
    int orderAmount = (Integer) row[2];     // 스칼라
}
```

#### NEW 명령어

- 앞선 예제에서는 `Object[]`를 반환했는데 실제는 `UserDTO` 같은 의미 있는 객체로 변환해서 사용한다.
- 객체를 변환하기 위해서 반복문 속에서 만들 수 있지만 `NEW` 명령어를 사용할 수도 있다.

```java
public class UserDto {
    private String username;
    private int age;
    
    public UserDTO(String username, int age) {
        this.username = username;
        this.age = age;
    }
    // ...
}
```

```
TypedQuery<UserDTO> query = em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m", UserDTO.class);

List<UserDTO> resultList = query.getResultList();
```

- `NEW` 명령어를 사용할 때는 다음 2가지를 주의해야 한다.
    1. 패키지 명을 포함한 전체 클래스 명을 입력해야 한다.
    2. 순서와 타입이 일치하는 생성자가 필요하다.
    
-----
[Home](./index.md)
