# 4. QueryDSL

- Criteria는 코드로 작성하므로 문법 오류를 컴파일 단계에서 잡을 수 있다.
- 또한 IDE의 자동완성 기능에게 도움을 받을 수 있다.
- 하지만 너무 복잡하고 어렵다는 단점이 있다.
- 쿼리를 코드로 작성해도 쉽고 간결하게 개발할 수 있는 것이 **QueryDSL**이다.


## 4.1 QueryDSL 설정

### 필요 라이브러리

- 예제에서 사용한 버전은 3.6.3이므로 라이브러리를 추가한다.

```
dependencies {
    // ...
    implementation 'com.mysema.querydsl:querydsl-jpa:3.6.3'
    implementation 'com.mysema.querydsl:querydsl-apt:3.6.3'
}
```

- `querydsl-jpa`: QueryDSL JPA 라이브러리
- `querydsl-apt`: 쿼리타입(Q)을 생성할 떄 필요한 라이브러리

### 환경설정

- QueryDSL을 사용하려면 Criteria의 메타 모델처럼 엔티티를 기반으로 쿼리 타입이라는 쿼리용 클래스를 생성해야 한다.
- 따라서 쿼리 타입 생성용 플러그인을 추가해야 한다.
- Gradle로 설정하면 복잡하다고 한다. 따라서 인터넷을 뒤져 설정을 찾았다.
    - [참고1](https://velog.io/@aidenshin/Querydsl-Gradle-설정)
    - [참고2](https://lteawoo.tistory.com/33)
    - 다 하고 난 뒤 터미널에서 `gralde compileQuerydsl`을 실행한다.

```groovy
plugins {
    // ...
    id "com.ewerk.gradle.plugins.querydsl" version "1.0.10"
}

// ...

dependencies {
    def querydlsVersion = '3.6.3'
    
    // ...
    implementation "com.mysema.querydsl:querydsl-jpa:$querydlsVersion"
    compileOnly "com.mysema.querydsl:querydsl-apt:$querydlsVersion"

    implementation "javax.annotation:javax.annotation-api:1.3.2"
    annotationProcessor "javax.annotation:javax.annotation-api:1.3.2"
}

// ...

//querydsl 추가 시작
def querydslDir = "$buildDir/generated/querydsl"

querydsl {
    jpa = true
    querydslSourcesDir = querydslDir
}

sourceSets {
    main.java.srcDir querydslDir
}

configurations {
    querydsl.extendsFrom compileClasspath
}

compileQuerydsl {
    options.annotationProcessorPath = configurations.querydsl
}
```

- `$buildDir/generated/querydsl` 폴더에 Q로 시작하는 쿼리 타입들이 생성된다.


## 4.2 시작

- QueryDSL을 어떻게 사용하는지 알아본다.

```
public void queryDSL() {
    EntityManager em = emf.createEntityManager();
    
    JPAQuery query = new JPAQuery(em);
    QMember qMember = new QMember("m");
    List<Member> members = query.from(qMember)
                                .where(qMember.name.eq("회원1"))
                                .orderBy(qMember.name.desc())
                                .list(qMember); 
}
```

- QueryDSL을 사용하려면 우선 `com.mysema.query.jpa.impl.JPAQuery` 객체를 생성해야 한다.
    - 생성할 떄 엔티티 매니저를 생성자에 넘겨준다.
- 그리고 사용할 쿼리 타입(Q)을 생성하는데 생성자에 별칭을 넘겨준다.

### 기본 Q 생성

- 쿼리 타입(Q)은 사용하기 편리하도록 기본 인스턴스를 보관하고 있다.
- 하지만 같은 엔티티를 조인하거나 같은 엔티티를 서브쿼리에 사용하면 같은 별칭이 사용된다.
- 이때는 별칭을 직접 지정해서 사용해야 한다.

```java
// Member 쿼리 타입
public class QMember extends EntityPathBase<Member> {
    public static final QMember member = new QMember("member1");
    // ...
}
```

```
QMember qMember = new QMember("m");     // 기본 지정
QMember qMember = QMember.member;       // 기본 인스턴스 사용
```

- 쿼리 타입의 기본 인스턴스를 사용하면 `import static`을 활용해서 코드를 더 간결하게 작성할 수 있다.

```
import static jpabook.jpashop.domain.QMember.member;   // 기본 인스턴스

public void basic() {
    EntityManager em = emf.createEntityManager();
    JPAQuery query = new JPAQuery(em);
    List<Member> members = query.from(member)
                                .where(member.name.eq("회원1"))
                                .orderBy(member.name.desc())
                                .list(member)
}
```


## 4.3 검색 조건 쿼리

```
// QueryDSL 기본 쿼리 기능
JPAQuery query = new JPAQuery(em);
QItem item = QItem.item;
List<Item> list = query.from(item)
  .where(item.name.eq("좋은상품").and(item.price.gt(20000)))
  .list(item);  // 조회할 프로젝션 지정
```

```
// 실행된 JPQL
select item
from Item item
where item.name = ?1 and item.price > ?2
```

- QueryDSL의 `where` 절에는 `and`나 `or`를 사용할 수 있다.
- 또한 다음처럼 여러 검색 조건을 사용해도 된다.

```
.where(item.name.eq("좋은상품"), item.price.gt(20000))
```

- 쿼리 타입의 필드는 필요한 대부분의 메서드를 명시적으로 제공한다.

```
item.price.between(10000, 20000)
item.name.contains("상품1")
item.name.startsWith("고급")
```


## 4.4 결과 조회

- 쿼리 작성이 끝나고 결과 조회 메서드를 호출하면 실제 데이터베이스를 조회한다.
- 대개 `uniqueResult()`나 `list()`를 사용하고 파라미터로 프로젝션 대상을 넘겨준다.
- 결과 조회 API는 `com.mysema.query.Projectable`에 정의되어 있다.
    - `uniqueResult()`
        - 결과가 한 건이다.
        - 결과가 없으면 null을 반환한다.
        - 둘 이상이면 `com.mysema.query.NonUniqueResultException` 예외가 발생한다.
    - `singleResult()`
        - `uniqueResut()`와 같지만, 둘 이상이면 처음 데이터를 반환한다.
    - `list()`
        - 결과가 둘 이상일 때 사용한다. 결과가 없으면 빈 컬렉션을 반환한다.
  

## 4.5 페이징과 정렬

```
QItem item = QItem.item;

query.from(item)
     .where(item.price.gt(20000))
     .orderBy(item.price.desc(), item.stockQuantity.asc())
     .offset(10).limit(20)
     .list(item);
```

- 정렬엔 `orderBy`를 사용하며 쿼리 타입(Q)이 제공하는 `asc()`, `desc()`를 사용한다.
- 페이징은 `offset()`과 `limit()`를 조합해서 사용한다.
- 페이징은 `restrict()` 메서드에 `com.mysema.query.QueryModifiers`를 파라미터로 사용해도 된다.

```
QueryModifiers queryModifiers = new QueryModifiers(20L, 10L); // limit, offset
List<Item> list = query.from(item)
                       .restrict(queryModifiers)
                       .list(item);
```

- 실제 페이징 처리를 하려면 검색된 전체 데이터 수를 알아야 한다.
- 이땐 `list()` 대신 `listResuts()`를 사용한다.

```
SearchResults<Item> result = query.from(item)
                                  .where(item.price.gt(10000))
                                  .offset(10).limit(20)
                                  .listResults(item);

long total = result.getTotal();
long limit = result.getLimit();
long offset = result.getOffset();
List<Item> results = result.getResults();
```

- `listResults()`를 사용하면 전체 데이터 조회를 위해 `count` 쿼리를 한 번 더 실행한다.


## 4.6 그룹

- `groupBy`를 사용하고 그룹화된 결과를 제한하려면 `having`을 사용하면 된다.

```
query.from(item)
     .groupBy(item.price)
     .having(item.price.gt(10000))
     .list(item);
```

-----
[Home](./index.md)
