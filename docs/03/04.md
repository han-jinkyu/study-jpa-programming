# 4. 영속성 컨텍스트의 특징

영속성 컨텍스트의 특징은 다음과 같다.

### 영속성 컨텍스트와 식별자 값

- 영속성 컨텍스트는 식별자 값(`@Id`로 매핑한 값)으로 엔티티를 구분한다.
- 따라서 영속 상태는 식별자 값이 반드시 있어야 한다. 없으면 예외가 발생한다. 

### 영속성 컨텍스트와 데이터베이스 저장

- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영한다.
- 이를 플러시(flush)라고 한다.

### 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩


## 4.1 엔티티 조회

- 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 **1차 캐시**라 부른다.
- 영속성 상태인 엔티티는 모두 이곳에 저장된다.
- 쉽게 얘기하면 영속성 컨텍스트 내부에 키는 `@Id`로 매핑한 식별자이며 값은 엔티티 인스턴스인 `Map`이 있다.

```
em.persist(member); // 아직 데이터베이스에 저장되지 않았다.
```

- 1차 캐시의 키는 식별자 값이며, 식별자 값은 데이터베이스 기본 키와 매핑되어 있다.
- 따라서 영속성 컨텍스트에 데이터를 저장/조회하는 모든 기준은 데이터베이스 기본키 값이다.

```
Member member = em.find(Member.class, "member1");   // 식별자로 검색한다.
```

- `em.find()`를 호출하면 먼저 1차 캐시에서 엔티티를 찾고, 없다면 데이터베이스에서 조회한다.

### 1차 캐시에서 조회

```
Member member = new Member();
member.setId("member1");
// ...

em.persist(member);     // 1차 캐시에 저장

Member findMember = em.find(Member.class, "member1");   // 1차 캐시에서 조회
```

### 데이터베이스에서 조회

- `em.find()`를 호출했는데 1차 캐시에 없다면 데이터베이스를 조회하여 엔티티를 생성한다.
- 그리고 1차 캐시에 저장한 후 영속 상태인 엔티티를 반환한다.
- 따라서 조회한 엔티티를 다시 조회하면 1차 캐시에서 바로 불러온다. 성능상 이점을 누릴 수 있다.

### 영속 엔티티의 동일성 보장

```
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");
System.out.println(a == b); // 동일성 비교. true가 나온다.
```

- 반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는 엔티티 인스턴스를 반환한다.
- 따라서 위와 같이 두 엔티티 인스턴스는 동일하다. 동일성(identity)을 보장한다.
- JPA는 1차 캐시를 통해 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 애플리케이션 차원에서 제공한다.


## 4.2 엔티티 등록

```
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();

transaction.begin();    // 트랜잭션 시작

em.persist(memberA);
em.persist(memberB);    // 아직 INSERT SQL을 DB에 보내지 않았다

transaction.commit();   // 트랜잭션 커밋. 이 순간 INSERT SQL을 보낸다 
```

- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL을 모아둔다.
- 트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보내는데 이를 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)이라 한다.
- 트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시(flush)한다.
- 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업이다. 동기를 마치고 데이터베이스에 커밋을 진행한다.

### 트랜잭션을 지원하는 쓰기 지연이 가능한 이유

다음 두 가지 로직을 비교해본다.

1. 데이터를 저장하는 즉시 등록 쿼리를 데이터베이스에 보내고 마지막에 트랜잭션을 커밋한다.
2. 데이터를 바로 보내지 않고 메모리에 모아둔 뒤, 트랜잭션을 커밋할 때 한꺼번에 등록 쿼리를 보내고 커밋한다.

- 결국 트랜잭션 범위 안에서 실행되므로 둘의 결과를 같다.
- 커밋하면 함께 저장되고 롤백하면 함께 저장되지 않는다.
- 따라서 트랜잭션을 지원하는 쓰기 지연이 가능해진다.

-----
[Home](./index.md)
