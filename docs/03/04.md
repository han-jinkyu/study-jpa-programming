# 4. 영속성 컨텍스트의 특징

영속성 컨텍스트의 특징은 다음과 같다.

### 영속성 컨텍스트와 식별자 값

- 영속성 컨텍스트는 식별자 값(`@Id`로 매핑한 값)으로 엔티티를 구분한다.
- 따라서 영속 상태는 식별자 값이 반드시 있어야 한다. 없으면 예외가 발생한다. 

### 영속성 컨텍스트와 데이터베이스 저장

- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영한다.
- 이를 플러시(flush)라고 한다.

### 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩


## 4.1 엔티티 조회

- 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 **1차 캐시**라 부른다.
- 영속성 상태인 엔티티는 모두 이곳에 저장된다.
- 쉽게 얘기하면 영속성 컨텍스트 내부에 키는 `@Id`로 매핑한 식별자이며 값은 엔티티 인스턴스인 `Map`이 있다.

```
em.persist(member); // 아직 데이터베이스에 저장되지 않았다.
```

- 1차 캐시의 키는 식별자 값이며, 식별자 값은 데이터베이스 기본 키와 매핑되어 있다.
- 따라서 영속성 컨텍스트에 데이터를 저장/조회하는 모든 기준은 데이터베이스 기본키 값이다.

```
Member member = em.find(Member.class, "member1");   // 식별자로 검색한다.
```

- `em.find()`를 호출하면 먼저 1차 캐시에서 엔티티를 찾고, 없다면 데이터베이스에서 조회한다.

### 1차 캐시에서 조회

```
Member member = new Member();
member.setId("member1");
// ...

em.persist(member);     // 1차 캐시에 저장

Member findMember = em.find(Member.class, "member1");   // 1차 캐시에서 조회
```

### 데이터베이스에서 조회

- `em.find()`를 호출했는데 1차 캐시에 없다면 데이터베이스를 조회하여 엔티티를 생성한다.
- 그리고 1차 캐시에 저장한 후 영속 상태인 엔티티를 반환한다.
- 따라서 조회한 엔티티를 다시 조회하면 1차 캐시에서 바로 불러온다. 성능상 이점을 누릴 수 있다.

### 영속 엔티티의 동일성 보장

```
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");
System.out.println(a == b); // 동일성 비교. true가 나온다.
```

- 반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는 엔티티 인스턴스를 반환한다.
- 따라서 위와 같이 두 엔티티 인스턴스는 동일하다. 동일성(identity)을 보장한다.
- JPA는 1차 캐시를 통해 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 애플리케이션 차원에서 제공한다.


## 4.2 엔티티 등록

```
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();

transaction.begin();    // 트랜잭션 시작

em.persist(memberA);
em.persist(memberB);    // 아직 INSERT SQL을 DB에 보내지 않았다

transaction.commit();   // 트랜잭션 커밋. 이 순간 INSERT SQL을 보낸다 
```

- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL을 모아둔다.
- 트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보내는데 이를 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)이라 한다.
- 트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시(flush)한다.
- 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업이다. 동기를 마치고 데이터베이스에 커밋을 진행한다.

### 트랜잭션을 지원하는 쓰기 지연이 가능한 이유

다음 두 가지 로직을 비교해본다.

1. 데이터를 저장하는 즉시 등록 쿼리를 데이터베이스에 보내고 마지막에 트랜잭션을 커밋한다.
2. 데이터를 바로 보내지 않고 메모리에 모아둔 뒤, 트랜잭션을 커밋할 때 한꺼번에 등록 쿼리를 보내고 커밋한다.

- 결국 트랜잭션 범위 안에서 실행되므로 둘의 결과를 같다.
- 커밋하면 함께 저장되고 롤백하면 함께 저장되지 않는다.
- 따라서 트랜잭션을 지원하는 쓰기 지연이 가능해진다.


## 4.3 엔티티 수정

### SQL 수정 쿼리의 문제점

- SQL을 사용하면 수정 쿼리를 직접 작성해야 한다.
- 프로젝트가 커지고 요구사항이 늘어나면 수정 쿼리도 점점 추가된다.
- 이런 개발 방식의 문제점은 수정 쿼리가 많아지는 것은 물론이며 비즈니스 로직을 분석하기 위해 SQL을 계속 확인해야 한다.
- 결국 직/간접적으로 비즈니스 로직이 SQL에 의존하게 된다.

### 변경 감지

```
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
transaction.begin();    // 트랜잭션 시작

Member memberA = em.find(Member.class, "memberA");  // 조회

// 영속 엔티티 데이터 수정
memberA.setUsername("hi");
memberA.setAge(10);

// em.update(memberA);  -> 이런 코드는 필요 없다.

transaction.commit();
```

- JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회하고 데이터만 변경하면 된다.
- 이렇게 엔티티의 변경사항을 DB에 자동으로 반영하는 기능을 변경 감지(dirty checking)라 한다.
- JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이를 **스냅샷**이라 한다.
- 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
- 변경 감지는 영속성 컨텍스트가 관리하는 **영속 상태**인 엔티티만 적용된다. 비영속, 준영속은 반영되지 않는다.
- JPA의 수정 기본 전략은 엔티티의 모든 필드를 업데이트한다. 
- 이는 DB에 보내는 데이터 전송량이 증가한다는 단점이 있으나 다음과 같은 장점으로 인해 모든 필드를 갱신한다.
    - 모든 필드를 사용하면 수정 쿼리가 항상 같다. 즉 애플리케이션 로딩 시점에 수정 쿼리를 만들고 재사용할 수 있다.
    - 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다.
- 필드가 많거나 저장되는 내용이 크면 동적으로 생성하는 전략을 사용하면 된다. 이 땐 하이버네이트 확장 기능을 사용해야 한다.

```java
@Entity
@org.hibernate.annotations.DynamicUpdate
@Table(name = "Member")
public class Member { /*...*/ }
```

- `null`이 아닌 필드만 INSERT SQL을 동적으로 실행하는 `@DynamicInsert`도 있다.
- 상황에 따라 다르지만 대개 컬럼이 30개 이상이 되면 동적 수정 쿼리가 빠르다고 한다.


## 4.4 엔티티 삭제

```
Member memberA = em.find(Member.class, "memberA");  // 삭제 대상 엔티티 조회
em.remove(memberA); // 삭제
```

- 엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다.
- 엔티티를 즉시 삭제하는 것이 아니라 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록한다.
- 이후 트랜잭션을 커밋해서 플러시를 호출하면 DB에 삭제 쿼리를 전달한다.
- `em.remove(memberA)`를 호출하는 순간 `memberA`는 영속성 컨텍스트에서 제거된다.
- 이렇게 삭제된 엔티티는 재사용하지 말고 가비지 컬렉션의 대상이 되도록 두는 것이 좋다.

-----
[Home](./index.md)
